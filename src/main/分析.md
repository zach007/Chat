#源码分析

####版本迭代
    1.1 一个简单的服务端接受一个简单的客户端连接，通过命令行显示客户端输入信息，.bye 同时关闭客户端和服务端
    1.2 上述的服务端功能，这次会服务端保持“open”来接受客户端信息，如果其中客户端断开。服务端一次最多能接受一个连接
    1.3 上述的服务端功能，同时处理多个客户端信息，所有的输出都会显示在界面上
    1.4 上述的功能服务，但是这次能够发送收到的信息给客户端，也就是说，服务端能接受和发送消息，客户端也能接受和发送消息
    1.5 将服务改为nio版本
    1.6 使用线程池管理线程
    1.7 将服务包装成为一个web程序，
    1.8 将服务包装成为一个安卓程序（kotlin）
    
####思路

#####1.1版本
    1.socket通讯
    
#####1.2版本 
    * 如何保持服务器常驻
    
    核心：使用线程保持socket连接
    原理：多线程来保持资源
    方法: implement Runable 接口，Thread.start()
    重构: 抽取业务代码,将Socket socket = socket.accept()放入线程中
    
#####1.3版本 
    * 为什么1.2版本不能同时接受多个client 
    原因：当有client连接进来的时候，socket可以建立连接（多个也行），
    因为有一个whilie(true)函数"阻塞了"streamIn.readUTF()
    解决： 每当有一个client连接上socket，建立了连接connection，就开一个线程，
    每一个socket都是一个线程，都提供读取socket.getInputStream(),然后交给system.out.print打印

#####1.4版本  
    * 为什么Socket+IO不是主流的通讯框架，
    Socket.accept()是阻塞的，同样的有inputStream.read()也是阻塞的，只有数据来的时候才会返回，
    因此每次socket连接的时候，都需要新建一个线程，造成线程浪费(线程资源比较宝贵)
    * NIO和普通IO有什么区别
    
| io                  | nio                 |
| ------------------- | ------------------- |
| 面向Stream           | 面向Buffer(块)       |
| 阻塞IO               | 阻塞IO               |
|                     | selector            |

    * 数据处理的不同
    面向流意味着你可以一次读取一个或多个字节，读到流的这些做什么你说了算，这里没有任何缓存，而且只能顺序从流中
    读取数据，如果需要跳过一些字节或者再读取已经读过的字节，必须将流中读取的数据先缓存起来。
    面向块处理时，数据先被读取的buffer中，根据需要可以控制读取的位置，增加了灵活性，但是需要确保数据已经全部读取到buffer中，
    或者更多数据进入buffer中，未处理的数据没有被覆盖
    javaIO流都是阻塞的，意味着当一个线程执行read()或者write()的时候，这条线程会一直阻塞直到读取到了一些数据或者数据已经写完了，
    期间不做任何事情。
    javaNio非阻塞的模式，允许一条线程从channel中读取数据，通过返回值来判断，通过返回值判断buffer中是否有数，如果没有数据NIO不会阻塞，
    因为不阻塞就可以做其他事情，过一段时间再回来判断有没有数据。
    
    Selectors
    Java NIO的selectors允许一条线程去监控多个channels的输入，你可以向一个selector上注册多个channel,
    然后调用selector的select()方法去判断是否有新的连接进来或者已经在selector上注册的channel是否有数据进入。selector机制
    让一个线程管理多个channel变得简单。
    
    当然会让程序变得更为复杂，处理文本的时候会变得复杂一点。
    
todo 
    
   
    
    

    
    


    

    
    


