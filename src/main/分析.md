#源码分析
* 为什么不能同时进行沟通
   	
   	1.构造函数：new serverSocket(port) 和 start()
   	2.其中start() -> new Thread()生成了一个线程
   	3.while thread != null -> 读取cmd的数据
   	总结： 也就是说线程状态没有改变，则线程一直常驻(触发机制是输入.bye)，就还是当前thread在监听数据，如果当前thread停止之后,stop函数没被调用过，线程一直处于激活状态，但只是单线程
   	
   	
   	
* 如何实现同时与服务器沟通  
    * 为什么需要实现有两个线程
        1. ChatServer 实现 runnable 是为了实现服务端常驻
        2. 重构代码中，一个server对应多一个clinet   
            思路：
            server端口，使用addThread()来创建新的thread
            client 抽取公共代码=》主要负责获取cmd数据
            
* 当Clinet连接port的时候，如何触发的多个线程，是不是run()实现了多次？
            
    * 线程基础知识
        1. start()只能执行一次
        2. run()可以重复执行多次
    * run()的意思是，只要这个thread状态不改变，不停止或死亡，run()方法占用的资源一直不释放。
      当Client连接port的时候，ServerSocket监听到了，就新增一个thread获取cmd输入
    * while(true) 此时程序进入死循环，一直着服务 
    
* 流程图
    1. 建立Socket联系，server端使用一个port,监听socket连接状态
    2. 使用一个Thread,保持服务端常驻，一直保持监听状态
    3. *当客户端连接port时候，触发了serverSocket.appept()，并且添加一个thread去读取cmd输入的文字
        1. 如何抽取核心代码，即需要抽象的资源
        
* 多线程作用
    1. port使用while(true)即可保持监听
    2. 多线程用在流上，即输入输出流，如果是单线程，可能某个人耗时过长，则后面聊天太慢了，需要等待，如果多线程则可以让每个人都“实时”  
    
* 怎么实现服务器和客户端相互通讯
    A : aaaa
    B : bbbb
    C : cccc
    D : dddd
    服务器 ： 接受A，返回给ABCD -> A
    
    将接受到的数据，返回给他们，关键：输入输出流 
    

    
    
  
   
   	 
	