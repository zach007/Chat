#源码分析

####版本迭代
    1.1 一个简单的服务端接受一个简单的客户端连接，通过命令行显示客户端输入信息，.bye 同时关闭客户端和服务端
    1.2 上述的服务端功能，这次会服务端保持“open”来接受客户端信息，如果其中客户端断开。服务端一次最多能接受一个连接
    1.3 上述的服务端功能，同时处理多个客户端信息，所有的输出都会显示在界面上
    1.4 上述的功能服务，但是这次能够发送收到的信息给客户端，也就是说，服务端能接受和发送消息，客户端也能接受和发送消息
    1.5 将服务包装成为一个web程序，
    1.6 将服务包装成为一个安卓程序（kotlin）
    
####思路

#####1.1版本
    1.socket通讯
    
#####1.2版本 
    * 如何保持服务器常驻
    
    核心：使用线程保持socket连接
    原理：多线程来保持资源
    方法: implement Runable 接口，Thread.start()
    重构: 抽取业务代码,将Socket socket = socket.accept()放入线程中
    
#####1.3版本 
    * 为什么1.2版本不能同时接受多个client 
    原因：当有client连接进来的时候，socket可以建立连接（多个也行），
    因为有一个whilie(true)函数"阻塞了"streamIn.readUTF()
    解决： 每当有一个client连接上socket，建立了连接connection，就开一个线程，
    每一个socket都是一个线程，都提供读取socket.getInputStream(),然后交给system.out.print打印

    
    
    


    

    
    


